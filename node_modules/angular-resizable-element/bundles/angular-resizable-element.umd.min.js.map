{
  "version": 3,
  "file": "angular-resizable-element.umd.min.js",
  "sources": [
    "ng://angular-resizable-element/src/resizable.directive.ts",
    "ng://angular-resizable-element/src/resize-handle.directive.ts",
    "ng://angular-resizable-element/src/resizable.module.ts"
  ],
  "sourcesContent": [
    "import {\n  Directive,\n  Renderer2,\n  ElementRef,\n  OnInit,\n  Output,\n  Input,\n  EventEmitter,\n  OnDestroy,\n  NgZone\n} from '@angular/core';\nimport { Subject, Observable, Observer, merge, interval } from 'rxjs';\nimport {\n  map,\n  mergeMap,\n  takeUntil,\n  filter,\n  pairwise,\n  take,\n  throttle,\n  share\n} from 'rxjs/operators';\nimport { Edges } from './interfaces/edges.interface';\nimport { BoundingRectangle } from './interfaces/bounding-rectangle.interface';\nimport { ResizeEvent } from './interfaces/resize-event.interface';\n\ninterface PointerEventCoordinate {\n  clientX: number;\n  clientY: number;\n  event: MouseEvent | TouchEvent;\n}\n\ninterface Coordinate {\n  x: number;\n  y: number;\n}\n\nfunction isNumberCloseTo(\n  value1: number,\n  value2: number,\n  precision: number = 3\n): boolean {\n  const diff: number = Math.abs(value1 - value2);\n  return diff < precision;\n}\n\nfunction getNewBoundingRectangle(\n  startingRect: BoundingRectangle,\n  edges: Edges,\n  clientX: number,\n  clientY: number\n): BoundingRectangle {\n  const newBoundingRect: BoundingRectangle = {\n    top: startingRect.top,\n    bottom: startingRect.bottom,\n    left: startingRect.left,\n    right: startingRect.right\n  };\n\n  if (edges.top) {\n    newBoundingRect.top += clientY;\n  }\n  if (edges.bottom) {\n    newBoundingRect.bottom += clientY;\n  }\n  if (edges.left) {\n    newBoundingRect.left += clientX;\n  }\n  if (edges.right) {\n    newBoundingRect.right += clientX;\n  }\n  newBoundingRect.height = newBoundingRect.bottom - newBoundingRect.top;\n  newBoundingRect.width = newBoundingRect.right - newBoundingRect.left;\n\n  return newBoundingRect;\n}\n\nfunction getElementRect(\n  element: ElementRef,\n  ghostElementPositioning: string\n): BoundingRectangle {\n  let translateX = 0;\n  let translateY = 0;\n  const style = element.nativeElement.style;\n  const transformProperties = [\n    'transform',\n    '-ms-transform',\n    '-moz-transform',\n    '-o-transform'\n  ];\n  const transform = transformProperties\n    .map(property => style[property])\n    .find(value => !!value);\n  if (transform && transform.includes('translate')) {\n    translateX = transform.replace(/.*translate\\((.*)px, (.*)px\\).*/, '$1');\n    translateY = transform.replace(/.*translate\\((.*)px, (.*)px\\).*/, '$2');\n  }\n\n  if (ghostElementPositioning === 'absolute') {\n    return {\n      height: element.nativeElement.offsetHeight,\n      width: element.nativeElement.offsetWidth,\n      top: element.nativeElement.offsetTop - translateY,\n      bottom:\n        element.nativeElement.offsetHeight +\n        element.nativeElement.offsetTop -\n        translateY,\n      left: element.nativeElement.offsetLeft - translateX,\n      right:\n        element.nativeElement.offsetWidth +\n        element.nativeElement.offsetLeft -\n        translateX\n    };\n  } else {\n    const boundingRect: BoundingRectangle = element.nativeElement.getBoundingClientRect();\n    return {\n      height: boundingRect.height,\n      width: boundingRect.width,\n      top: boundingRect.top - translateY,\n      bottom: boundingRect.bottom - translateY,\n      left: boundingRect.left - translateX,\n      right: boundingRect.right - translateX,\n      scrollTop: element.nativeElement.scrollTop,\n      scrollLeft: element.nativeElement.scrollLeft\n    };\n  }\n}\n\nfunction isWithinBoundingY({\n  clientY,\n  rect\n}: {\n  clientY: number;\n  rect: ClientRect;\n}): boolean {\n  return clientY >= rect.top && clientY <= rect.bottom;\n}\n\nfunction isWithinBoundingX({\n  clientX,\n  rect\n}: {\n  clientX: number;\n  rect: ClientRect;\n}): boolean {\n  return clientX >= rect.left && clientX <= rect.right;\n}\n\nfunction getResizeEdges({\n  clientX,\n  clientY,\n  elm,\n  allowedEdges,\n  cursorPrecision\n}: {\n  clientX: number;\n  clientY: number;\n  elm: ElementRef;\n  allowedEdges: Edges;\n  cursorPrecision: number;\n}): Edges {\n  const elmPosition: ClientRect = elm.nativeElement.getBoundingClientRect();\n  const edges: Edges = {};\n\n  if (\n    allowedEdges.left &&\n    isNumberCloseTo(clientX, elmPosition.left, cursorPrecision) &&\n    isWithinBoundingY({ clientY, rect: elmPosition })\n  ) {\n    edges.left = true;\n  }\n\n  if (\n    allowedEdges.right &&\n    isNumberCloseTo(clientX, elmPosition.right, cursorPrecision) &&\n    isWithinBoundingY({ clientY, rect: elmPosition })\n  ) {\n    edges.right = true;\n  }\n\n  if (\n    allowedEdges.top &&\n    isNumberCloseTo(clientY, elmPosition.top, cursorPrecision) &&\n    isWithinBoundingX({ clientX, rect: elmPosition })\n  ) {\n    edges.top = true;\n  }\n\n  if (\n    allowedEdges.bottom &&\n    isNumberCloseTo(clientY, elmPosition.bottom, cursorPrecision) &&\n    isWithinBoundingX({ clientX, rect: elmPosition })\n  ) {\n    edges.bottom = true;\n  }\n\n  return edges;\n}\n\nexport interface ResizeCursors {\n  topLeft: string;\n  topRight: string;\n  bottomLeft: string;\n  bottomRight: string;\n  leftOrRight: string;\n  topOrBottom: string;\n}\n\nconst DEFAULT_RESIZE_CURSORS: ResizeCursors = Object.freeze({\n  topLeft: 'nw-resize',\n  topRight: 'ne-resize',\n  bottomLeft: 'sw-resize',\n  bottomRight: 'se-resize',\n  leftOrRight: 'ew-resize',\n  topOrBottom: 'ns-resize'\n});\n\nfunction getResizeCursor(edges: Edges, cursors: ResizeCursors): string {\n  if (edges.left && edges.top) {\n    return cursors.topLeft;\n  } else if (edges.right && edges.top) {\n    return cursors.topRight;\n  } else if (edges.left && edges.bottom) {\n    return cursors.bottomLeft;\n  } else if (edges.right && edges.bottom) {\n    return cursors.bottomRight;\n  } else if (edges.left || edges.right) {\n    return cursors.leftOrRight;\n  } else if (edges.top || edges.bottom) {\n    return cursors.topOrBottom;\n  } else {\n    return '';\n  }\n}\n\nfunction getEdgesDiff({\n  edges,\n  initialRectangle,\n  newRectangle\n}: {\n  edges: Edges;\n  initialRectangle: BoundingRectangle;\n  newRectangle: BoundingRectangle;\n}): Edges {\n  const edgesDiff: Edges = {};\n  Object.keys(edges).forEach(edge => {\n    edgesDiff[edge] = (newRectangle[edge] || 0) - (initialRectangle[edge] || 0);\n  });\n  return edgesDiff;\n}\n\nconst RESIZE_ACTIVE_CLASS: string = 'resize-active';\nconst RESIZE_LEFT_HOVER_CLASS: string = 'resize-left-hover';\nconst RESIZE_RIGHT_HOVER_CLASS: string = 'resize-right-hover';\nconst RESIZE_TOP_HOVER_CLASS: string = 'resize-top-hover';\nconst RESIZE_BOTTOM_HOVER_CLASS: string = 'resize-bottom-hover';\nconst RESIZE_GHOST_ELEMENT_CLASS: string = 'resize-ghost-element';\n\nexport const MOUSE_MOVE_THROTTLE_MS: number = 50;\n\n/**\n * Place this on an element to make it resizable. For example:\n *\n * ```html\n * <div\n *   mwlResizable\n *   [resizeEdges]=\"{bottom: true, right: true, top: true, left: true}\"\n *   [enableGhostResize]=\"true\">\n * </div>\n * ```\n */\n@Directive({\n  selector: '[mwlResizable]'\n})\nexport class ResizableDirective implements OnInit, OnDestroy {\n  /**\n   * A function that will be called before each resize event. Return `true` to allow the resize event to propagate or `false` to cancel it\n   */\n  @Input() validateResize: (resizeEvent: ResizeEvent) => boolean;\n\n  /**\n   * The edges that an element can be resized from. Pass an object like `{top: true, bottom: false}`. By default no edges can be resized.\n   */\n  @Input() resizeEdges: Edges = {};\n\n  /**\n   * Set to `true` to enable a temporary resizing effect of the element in between the `resizeStart` and `resizeEnd` events.\n   */\n  @Input() enableGhostResize: boolean = false;\n\n  /**\n   * A snap grid that resize events will be locked to.\n   *\n   * e.g. to only allow the element to be resized every 10px set it to `{left: 10, right: 10}`\n   */\n  @Input() resizeSnapGrid: Edges = {};\n\n  /**\n   * The mouse cursors that will be set on the resize edges\n   */\n  @Input() resizeCursors: ResizeCursors = DEFAULT_RESIZE_CURSORS;\n\n  /**\n   * Mouse over thickness to active cursor.\n   */\n  @Input() resizeCursorPrecision: number = 3;\n\n  /**\n   * Define the positioning of the ghost element (can be fixed or absolute)\n   */\n  @Input() ghostElementPositioning: 'fixed' | 'absolute' = 'fixed';\n\n  /**\n   * Called when the mouse is pressed and a resize event is about to begin. `$event` is a `ResizeEvent` object.\n   */\n  @Output() resizeStart = new EventEmitter<ResizeEvent>();\n\n  /**\n   * Called as the mouse is dragged after a resize event has begun. `$event` is a `ResizeEvent` object.\n   */\n  @Output() resizing = new EventEmitter<ResizeEvent>();\n\n  /**\n   * Called after the mouse is released after a resize event. `$event` is a `ResizeEvent` object.\n   */\n  @Output() resizeEnd = new EventEmitter<ResizeEvent>();\n\n  /**\n   * @hidden\n   */\n  public mouseup = new Subject<{\n    clientX: number;\n    clientY: number;\n    edges?: Edges;\n  }>();\n\n  /**\n   * @hidden\n   */\n  public mousedown = new Subject<{\n    clientX: number;\n    clientY: number;\n    edges?: Edges;\n  }>();\n\n  /**\n   * @hidden\n   */\n  public mousemove = new Subject<{\n    clientX: number;\n    clientY: number;\n    edges?: Edges;\n    event: MouseEvent | TouchEvent;\n  }>();\n\n  private pointerEventListeners: PointerEventListeners;\n\n  private pointerEventListenerSubscriptions: any = {};\n\n  /**\n   * @hidden\n   */\n  constructor(\n    private renderer: Renderer2,\n    public elm: ElementRef,\n    private zone: NgZone\n  ) {\n    this.pointerEventListeners = PointerEventListeners.getInstance(\n      renderer,\n      zone\n    );\n  }\n\n  /**\n   * @hidden\n   */\n  ngOnInit(): void {\n    // TODO - use some fancy Observable.merge's for this\n    this.pointerEventListenerSubscriptions.pointerDown = this.pointerEventListeners.pointerDown.subscribe(\n      ({ clientX, clientY }) => {\n        this.mousedown.next({ clientX, clientY });\n      }\n    );\n\n    this.pointerEventListenerSubscriptions.pointerMove = this.pointerEventListeners.pointerMove.subscribe(\n      ({ clientX, clientY, event }) => {\n        this.mousemove.next({ clientX, clientY, event });\n      }\n    );\n\n    this.pointerEventListenerSubscriptions.pointerUp = this.pointerEventListeners.pointerUp.subscribe(\n      ({ clientX, clientY }) => {\n        this.mouseup.next({ clientX, clientY });\n      }\n    );\n\n    let currentResize: {\n      edges: Edges;\n      startingRect: BoundingRectangle;\n      currentRect: BoundingRectangle;\n      clonedNode?: HTMLElement;\n    } | null;\n\n    const removeGhostElement = () => {\n      if (currentResize && currentResize.clonedNode) {\n        this.elm.nativeElement.parentElement.removeChild(\n          currentResize.clonedNode\n        );\n        this.renderer.setStyle(this.elm.nativeElement, 'visibility', 'inherit');\n      }\n    };\n\n    const mouseMove: Observable<any> = this.mousemove.pipe(share());\n\n    mouseMove.pipe(filter(() => !!currentResize)).subscribe(({ event }) => {\n      event.preventDefault();\n    });\n\n    mouseMove\n      .pipe(throttle(() => interval(MOUSE_MOVE_THROTTLE_MS)))\n      .subscribe(({ clientX, clientY }) => {\n        const resizeEdges: Edges = getResizeEdges({\n          clientX,\n          clientY,\n          elm: this.elm,\n          allowedEdges: this.resizeEdges,\n          cursorPrecision: this.resizeCursorPrecision\n        });\n        const resizeCursors: ResizeCursors = Object.assign(\n          {},\n          DEFAULT_RESIZE_CURSORS,\n          this.resizeCursors\n        );\n        if (currentResize) {\n          const cursor: string = getResizeCursor(\n            currentResize.edges,\n            resizeCursors\n          );\n          this.renderer.setStyle(document.body, 'cursor', cursor);\n        } else {\n          const cursor: string = getResizeCursor(resizeEdges, resizeCursors);\n          this.renderer.setStyle(this.elm.nativeElement, 'cursor', cursor);\n        }\n        this.setElementClass(this.elm, RESIZE_ACTIVE_CLASS, !!currentResize);\n        this.setElementClass(\n          this.elm,\n          RESIZE_LEFT_HOVER_CLASS,\n          resizeEdges.left === true\n        );\n        this.setElementClass(\n          this.elm,\n          RESIZE_RIGHT_HOVER_CLASS,\n          resizeEdges.right === true\n        );\n        this.setElementClass(\n          this.elm,\n          RESIZE_TOP_HOVER_CLASS,\n          resizeEdges.top === true\n        );\n        this.setElementClass(\n          this.elm,\n          RESIZE_BOTTOM_HOVER_CLASS,\n          resizeEdges.bottom === true\n        );\n      });\n\n    const mousedrag: Observable<any> = this.mousedown\n      .pipe(\n        mergeMap(startCoords => {\n          function getDiff(moveCoords: { clientX: number; clientY: number }) {\n            return {\n              clientX: moveCoords.clientX - startCoords.clientX,\n              clientY: moveCoords.clientY - startCoords.clientY\n            };\n          }\n\n          const getSnapGrid = () => {\n            const snapGrid: Coordinate = { x: 1, y: 1 };\n\n            if (currentResize) {\n              if (this.resizeSnapGrid.left && currentResize.edges.left) {\n                snapGrid.x = +this.resizeSnapGrid.left;\n              } else if (\n                this.resizeSnapGrid.right &&\n                currentResize.edges.right\n              ) {\n                snapGrid.x = +this.resizeSnapGrid.right;\n              }\n\n              if (this.resizeSnapGrid.top && currentResize.edges.top) {\n                snapGrid.y = +this.resizeSnapGrid.top;\n              } else if (\n                this.resizeSnapGrid.bottom &&\n                currentResize.edges.bottom\n              ) {\n                snapGrid.y = +this.resizeSnapGrid.bottom;\n              }\n            }\n\n            return snapGrid;\n          };\n\n          function getGrid(\n            coords: { clientX: number; clientY: number },\n            snapGrid: Coordinate\n          ) {\n            return {\n              x: Math.ceil(coords.clientX / snapGrid.x),\n              y: Math.ceil(coords.clientY / snapGrid.y)\n            };\n          }\n\n          return merge(\n            mouseMove.pipe(take(1)).pipe(map(coords => [, coords])),\n            mouseMove.pipe(pairwise())\n          )\n            .pipe(\n              map(([previousCoords, newCoords]) => {\n                return [\n                  previousCoords ? getDiff(previousCoords) : previousCoords,\n                  getDiff(newCoords)\n                ];\n              })\n            )\n            .pipe(\n              filter(([previousCoords, newCoords]) => {\n                if (!previousCoords) {\n                  return true;\n                }\n\n                const snapGrid: Coordinate = getSnapGrid();\n                const previousGrid: Coordinate = getGrid(\n                  previousCoords,\n                  snapGrid\n                );\n                const newGrid: Coordinate = getGrid(newCoords, snapGrid);\n\n                return (\n                  previousGrid.x !== newGrid.x || previousGrid.y !== newGrid.y\n                );\n              })\n            )\n            .pipe(\n              map(([, newCoords]) => {\n                const snapGrid: Coordinate = getSnapGrid();\n                return {\n                  clientX:\n                    Math.round(newCoords.clientX / snapGrid.x) * snapGrid.x,\n                  clientY:\n                    Math.round(newCoords.clientY / snapGrid.y) * snapGrid.y\n                };\n              })\n            )\n            .pipe(takeUntil(merge(this.mouseup, this.mousedown)));\n        })\n      )\n      .pipe(filter(() => !!currentResize));\n\n    mousedrag\n      .pipe(\n        map(({ clientX, clientY }) => {\n          return getNewBoundingRectangle(\n            currentResize!.startingRect,\n            currentResize!.edges,\n            clientX,\n            clientY\n          );\n        })\n      )\n      .pipe(\n        filter((newBoundingRect: BoundingRectangle) => {\n          return !!(\n            newBoundingRect.height &&\n            newBoundingRect.width &&\n            newBoundingRect.height > 0 &&\n            newBoundingRect.width > 0\n          );\n        })\n      )\n      .pipe(\n        filter((newBoundingRect: BoundingRectangle) => {\n          return this.validateResize\n            ? this.validateResize({\n                rectangle: newBoundingRect,\n                edges: getEdgesDiff({\n                  edges: currentResize!.edges,\n                  initialRectangle: currentResize!.startingRect,\n                  newRectangle: newBoundingRect\n                })\n              })\n            : true;\n        })\n      )\n      .subscribe((newBoundingRect: BoundingRectangle) => {\n        if (currentResize && currentResize.clonedNode) {\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'height',\n            `${newBoundingRect.height}px`\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'width',\n            `${newBoundingRect.width}px`\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'top',\n            `${newBoundingRect.top}px`\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'left',\n            `${newBoundingRect.left}px`\n          );\n        }\n\n        this.zone.run(() => {\n          this.resizing.emit({\n            edges: getEdgesDiff({\n              edges: currentResize!.edges,\n              initialRectangle: currentResize!.startingRect,\n              newRectangle: newBoundingRect\n            }),\n            rectangle: newBoundingRect\n          });\n        });\n\n        currentResize!.currentRect = newBoundingRect;\n      });\n\n    this.mousedown\n      .pipe(\n        map(({ clientX, clientY, edges }) => {\n          return (\n            edges ||\n            getResizeEdges({\n              clientX,\n              clientY,\n              elm: this.elm,\n              allowedEdges: this.resizeEdges,\n              cursorPrecision: this.resizeCursorPrecision\n            })\n          );\n        })\n      )\n      .pipe(\n        filter((edges: Edges) => {\n          return Object.keys(edges).length > 0;\n        })\n      )\n      .subscribe((edges: Edges) => {\n        if (currentResize) {\n          removeGhostElement();\n        }\n        const startingRect: BoundingRectangle = getElementRect(\n          this.elm,\n          this.ghostElementPositioning\n        );\n        currentResize = {\n          edges,\n          startingRect,\n          currentRect: startingRect\n        };\n        if (this.enableGhostResize) {\n          currentResize.clonedNode = this.elm.nativeElement.cloneNode(true);\n          const resizeCursors: ResizeCursors = Object.assign(\n            {},\n            DEFAULT_RESIZE_CURSORS,\n            this.resizeCursors\n          );\n          this.elm.nativeElement.parentElement.appendChild(\n            currentResize.clonedNode\n          );\n          this.renderer.setStyle(\n            this.elm.nativeElement,\n            'visibility',\n            'hidden'\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'position',\n            this.ghostElementPositioning\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'left',\n            `${currentResize.startingRect.left}px`\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'top',\n            `${currentResize.startingRect.top}px`\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'height',\n            `${currentResize.startingRect.height}px`\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'width',\n            `${currentResize.startingRect.width}px`\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'cursor',\n            getResizeCursor(currentResize.edges, resizeCursors)\n          );\n          this.renderer.addClass(\n            currentResize.clonedNode,\n            RESIZE_GHOST_ELEMENT_CLASS\n          );\n          currentResize.clonedNode!.scrollTop = currentResize.startingRect\n            .scrollTop as number;\n          currentResize.clonedNode!.scrollLeft = currentResize.startingRect\n            .scrollLeft as number;\n        }\n        this.zone.run(() => {\n          this.resizeStart.emit({\n            edges: getEdgesDiff({\n              edges,\n              initialRectangle: startingRect,\n              newRectangle: startingRect\n            }),\n            rectangle: getNewBoundingRectangle(startingRect, {}, 0, 0)\n          });\n        });\n      });\n\n    this.mouseup.subscribe(() => {\n      if (currentResize) {\n        this.renderer.removeClass(this.elm.nativeElement, RESIZE_ACTIVE_CLASS);\n        this.renderer.setStyle(document.body, 'cursor', '');\n        this.renderer.setStyle(this.elm.nativeElement, 'cursor', '');\n        this.zone.run(() => {\n          this.resizeEnd.emit({\n            edges: getEdgesDiff({\n              edges: currentResize!.edges,\n              initialRectangle: currentResize!.startingRect,\n              newRectangle: currentResize!.currentRect\n            }),\n            rectangle: currentResize!.currentRect\n          });\n        });\n        removeGhostElement();\n        currentResize = null;\n      }\n    });\n  }\n\n  /**\n   * @hidden\n   */\n  ngOnDestroy(): void {\n    this.mousedown.complete();\n    this.mouseup.complete();\n    this.mousemove.complete();\n    this.pointerEventListenerSubscriptions.pointerDown.unsubscribe();\n    this.pointerEventListenerSubscriptions.pointerMove.unsubscribe();\n    this.pointerEventListenerSubscriptions.pointerUp.unsubscribe();\n  }\n\n  private setElementClass(elm: ElementRef, name: string, add: boolean): void {\n    if (add) {\n      this.renderer.addClass(elm.nativeElement, name);\n    } else {\n      this.renderer.removeClass(elm.nativeElement, name);\n    }\n  }\n}\n\nclass PointerEventListeners {\n  public pointerDown: Observable<PointerEventCoordinate>;\n\n  public pointerMove: Observable<PointerEventCoordinate>;\n\n  public pointerUp: Observable<PointerEventCoordinate>;\n\n  private static instance: PointerEventListeners; // tslint:disable-line\n\n  public static getInstance(\n    renderer: Renderer2,\n    zone: NgZone\n  ): PointerEventListeners {\n    if (!PointerEventListeners.instance) {\n      PointerEventListeners.instance = new PointerEventListeners(\n        renderer,\n        zone\n      );\n    }\n    return PointerEventListeners.instance;\n  }\n\n  constructor(renderer: Renderer2, zone: NgZone) {\n    this.pointerDown = new Observable(\n      (observer: Observer<PointerEventCoordinate>) => {\n        let unsubscribeMouseDown: () => void;\n        let unsubscribeTouchStart: () => void;\n\n        zone.runOutsideAngular(() => {\n          unsubscribeMouseDown = renderer.listen(\n            'document',\n            'mousedown',\n            (event: MouseEvent) => {\n              observer.next({\n                clientX: event.clientX,\n                clientY: event.clientY,\n                event\n              });\n            }\n          );\n\n          unsubscribeTouchStart = renderer.listen(\n            'document',\n            'touchstart',\n            (event: TouchEvent) => {\n              observer.next({\n                clientX: event.touches[0].clientX,\n                clientY: event.touches[0].clientY,\n                event\n              });\n            }\n          );\n        });\n\n        return () => {\n          unsubscribeMouseDown();\n          unsubscribeTouchStart();\n        };\n      }\n    ).pipe(share());\n\n    this.pointerMove = new Observable(\n      (observer: Observer<PointerEventCoordinate>) => {\n        let unsubscribeMouseMove: () => void;\n        let unsubscribeTouchMove: () => void;\n\n        zone.runOutsideAngular(() => {\n          unsubscribeMouseMove = renderer.listen(\n            'document',\n            'mousemove',\n            (event: MouseEvent) => {\n              observer.next({\n                clientX: event.clientX,\n                clientY: event.clientY,\n                event\n              });\n            }\n          );\n\n          unsubscribeTouchMove = renderer.listen(\n            'document',\n            'touchmove',\n            (event: TouchEvent) => {\n              observer.next({\n                clientX: event.targetTouches[0].clientX,\n                clientY: event.targetTouches[0].clientY,\n                event\n              });\n            }\n          );\n        });\n\n        return () => {\n          unsubscribeMouseMove();\n          unsubscribeTouchMove();\n        };\n      }\n    ).pipe(share());\n\n    this.pointerUp = new Observable(\n      (observer: Observer<PointerEventCoordinate>) => {\n        let unsubscribeMouseUp: () => void;\n        let unsubscribeTouchEnd: () => void;\n        let unsubscribeTouchCancel: () => void;\n\n        zone.runOutsideAngular(() => {\n          unsubscribeMouseUp = renderer.listen(\n            'document',\n            'mouseup',\n            (event: MouseEvent) => {\n              observer.next({\n                clientX: event.clientX,\n                clientY: event.clientY,\n                event\n              });\n            }\n          );\n\n          unsubscribeTouchEnd = renderer.listen(\n            'document',\n            'touchend',\n            (event: TouchEvent) => {\n              observer.next({\n                clientX: event.changedTouches[0].clientX,\n                clientY: event.changedTouches[0].clientY,\n                event\n              });\n            }\n          );\n\n          unsubscribeTouchCancel = renderer.listen(\n            'document',\n            'touchcancel',\n            (event: TouchEvent) => {\n              observer.next({\n                clientX: event.changedTouches[0].clientX,\n                clientY: event.changedTouches[0].clientY,\n                event\n              });\n            }\n          );\n        });\n\n        return () => {\n          unsubscribeMouseUp();\n          unsubscribeTouchEnd();\n          unsubscribeTouchCancel();\n        };\n      }\n    ).pipe(share());\n  }\n}\n",
    "import {\n  Directive,\n  Input,\n  HostListener,\n  Renderer2,\n  ElementRef,\n  OnDestroy,\n  NgZone\n} from '@angular/core';\nimport { ResizableDirective } from './resizable.directive';\nimport { Edges } from './interfaces/edges.interface';\n\n/**\n * An element placed inside a `mwlResizable` directive to be used as a drag and resize handle\n *\n * For example\n *\n * ```html\n * <div mwlResizable>\n *   <div mwlResizeHandle [resizeEdges]=\"{bottom: true, right: true}\"></div>\n * </div>\n * ```\n */\n@Directive({\n  selector: '[mwlResizeHandle]'\n})\nexport class ResizeHandleDirective implements OnDestroy {\n  /**\n   * The `Edges` object that contains the edges of the parent element that dragging the handle will trigger a resize on\n   */\n  @Input() resizeEdges: Edges = {};\n\n  private eventListeners: {\n    touchmove?: () => void;\n    mousemove?: () => void;\n    [key: string]: (() => void) | undefined;\n  } = {};\n\n  constructor(\n    private renderer: Renderer2,\n    private element: ElementRef,\n    private zone: NgZone,\n    private resizable: ResizableDirective\n  ) {}\n\n  ngOnDestroy(): void {\n    this.unsubscribeEventListeners();\n  }\n\n  /**\n   * @hidden\n   */\n  @HostListener('touchstart', [\n    '$event',\n    '$event.touches[0].clientX',\n    '$event.touches[0].clientY'\n  ])\n  @HostListener('mousedown', ['$event', '$event.clientX', '$event.clientY'])\n  onMousedown(\n    event: MouseEvent | TouchEvent,\n    clientX: number,\n    clientY: number\n  ): void {\n    event.preventDefault();\n    this.zone.runOutsideAngular(() => {\n      if (!this.eventListeners.touchmove) {\n        this.eventListeners.touchmove = this.renderer.listen(\n          this.element.nativeElement,\n          'touchmove',\n          (touchMoveEvent: TouchEvent) => {\n            this.onMousemove(\n              touchMoveEvent,\n              touchMoveEvent.targetTouches[0].clientX,\n              touchMoveEvent.targetTouches[0].clientY\n            );\n          }\n        );\n      }\n      if (!this.eventListeners.mousemove) {\n        this.eventListeners.mousemove = this.renderer.listen(\n          this.element.nativeElement,\n          'mousemove',\n          (mouseMoveEvent: MouseEvent) => {\n            this.onMousemove(\n              mouseMoveEvent,\n              mouseMoveEvent.clientX,\n              mouseMoveEvent.clientY\n            );\n          }\n        );\n      }\n      this.resizable.mousedown.next({\n        clientX,\n        clientY,\n        edges: this.resizeEdges\n      });\n    });\n  }\n\n  /**\n   * @hidden\n   */\n  @HostListener('touchend', [\n    '$event.changedTouches[0].clientX',\n    '$event.changedTouches[0].clientY'\n  ])\n  @HostListener('touchcancel', [\n    '$event.changedTouches[0].clientX',\n    '$event.changedTouches[0].clientY'\n  ])\n  @HostListener('mouseup', ['$event.clientX', '$event.clientY'])\n  onMouseup(clientX: number, clientY: number): void {\n    this.zone.runOutsideAngular(() => {\n      this.unsubscribeEventListeners();\n      this.resizable.mouseup.next({\n        clientX,\n        clientY,\n        edges: this.resizeEdges\n      });\n    });\n  }\n\n  private onMousemove(\n    event: MouseEvent | TouchEvent,\n    clientX: number,\n    clientY: number\n  ): void {\n    this.resizable.mousemove.next({\n      clientX,\n      clientY,\n      edges: this.resizeEdges,\n      event\n    });\n  }\n\n  private unsubscribeEventListeners(): void {\n    Object.keys(this.eventListeners).forEach(type => {\n      (this as any).eventListeners[type]();\n      delete this.eventListeners[type];\n    });\n  }\n}\n",
    "import { NgModule } from '@angular/core';\nimport { ResizableDirective } from './resizable.directive';\nimport { ResizeHandleDirective } from './resize-handle.directive';\n\n@NgModule({\n  declarations: [ResizableDirective, ResizeHandleDirective],\n  exports: [ResizableDirective, ResizeHandleDirective]\n})\nexport class ResizableModule {}\n"
  ],
  "names": [
    "isNumberCloseTo",
    "value1",
    "value2",
    "precision",
    "Math",
    "abs",
    "getNewBoundingRectangle",
    "startingRect",
    "edges",
    "clientX",
    "clientY",
    "newBoundingRect",
    "top",
    "bottom",
    "left",
    "right",
    "height",
    "width",
    "isWithinBoundingY",
    "_a",
    "getResizeEdges",
    "elm",
    "allowedEdges",
    "cursorPrecision",
    "elmPosition",
    "nativeElement",
    "getBoundingClientRect",
    "rect",
    "isWithinBoundingX",
    "DEFAULT_RESIZE_CURSORS",
    "Object",
    "freeze",
    "topLeft",
    "topRight",
    "getResizeCursor",
    "cursors",
    "bottomLeft",
    "bottomRight",
    "leftOrRight",
    "topOrBottom",
    "getEdgesDiff",
    "initialRectangle",
    "newRectangle",
    "edgesDiff",
    "keys",
    "forEach",
    "edge",
    "RESIZE_ACTIVE_CLASS",
    "this",
    "renderer",
    "enableGhostResize",
    "mousedown",
    "Subject",
    "pointerEventListeners",
    "PointerEventListeners",
    "getInstance",
    "zone",
    "ResizableDirective",
    "prototype",
    "ngOnInit",
    "currentResize",
    "_this",
    "pointerEventListenerSubscriptions",
    "pointerDown",
    "subscribe",
    "next",
    "pointerMove",
    "event",
    "mousemove",
    "pointerUp",
    "mouseup",
    "removeGhostElement",
    "clonedNode",
    "parentElement",
    "removeChild",
    "setStyle",
    "mouseMove",
    "pipe",
    "share",
    "filter",
    "preventDefault",
    "throttle",
    "interval",
    "resizeEdges",
    "resizeCursorPrecision",
    "resizeCursors",
    "assign",
    "cursor",
    "document",
    "body",
    "setElementClass",
    "mergeMap",
    "startCoords",
    "getDiff",
    "moveCoords",
    "getSnapGrid",
    "snapGrid",
    "x",
    "y",
    "resizeSnapGrid",
    "getGrid",
    "coords",
    "ceil",
    "merge",
    "take",
    "map",
    "pairwise",
    "_b",
    "tslib_1.__read",
    "previousCoords",
    "newCoords",
    "previousGrid",
    "newGrid",
    "round",
    "takeUntil",
    "validateResize",
    "rectangle",
    "run",
    "resizing",
    "emit",
    "currentRect",
    "length",
    "element",
    "ghostElementPositioning",
    "translateX",
    "translateY",
    "style",
    "transform",
    "property",
    "find",
    "value",
    "includes",
    "replace",
    "offsetHeight",
    "offsetWidth",
    "offsetTop",
    "offsetLeft",
    "boundingRect",
    "scrollTop",
    "scrollLeft",
    "getElementRect",
    "cloneNode",
    "appendChild",
    "addClass",
    "resizeStart",
    "removeClass",
    "ngOnDestroy",
    "complete",
    "name",
    "add",
    "decorators",
    "type",
    "Directive",
    "args",
    "selector",
    "Observable",
    "observer",
    "unsubscribeMouseDown",
    "unsubscribeTouchStart",
    "runOutsideAngular",
    "listen",
    "touches",
    "unsubscribeMouseMove",
    "unsubscribeTouchMove",
    "targetTouches",
    "unsubscribeMouseUp",
    "unsubscribeTouchEnd",
    "unsubscribeTouchCancel",
    "changedTouches",
    "ResizeHandleDirective",
    "resizable",
    "eventListeners",
    "unsubscribeEventListeners",
    "onMousedown",
    "touchmove",
    "touchMoveEvent",
    "onMousemove",
    "mouseMoveEvent",
    "onMouseup",
    "ElementRef",
    "NgZone",
    "propDecorators",
    "Input",
    "HostListener",
    "ResizableModule"
  ],
  "mappings": "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"
}
